# Solid это не сложно. С примерами на Python

## Введение

Привет, Хабр! Меня зовут Павел Корсаков, я python-разработчик, backend-developer в облачном
провайдере [beeline cloud](https://cloud.beeline.ru/?utm_source=owned_media&utm_medium=habr&utm_campaign=beeline_cloud&utm_term=bpod-kapotom-python-tonkosti-populyarnyh-konstrukciy-with-i-contextmanager).

Почти на всех на собеседованиях есть вопрос про SOLID. Что такое SOLID. Зачем он нужен. Как кандидат его применяет. Как
понимает принципы из него. Спрашиваем про SOLID потому, что он часто бывает аргументом на ревью. Разработчики с опытом на
больших и энтерпайзных проектах частенько предлагают применить какой-нибудь из принципов SOLID там, где он на первый
взгляд вроде бы и не нужен.

Но вернемся к кандидатам. Чаше всего кандидат рассказывает что SOLID это акроним, называет все принципы, но объяснить и
привести примеры может только для половины. На остальных либо плавает, либо сливается.

Интернет по SOLID предлагает множество статей. Как на русском, так и на иностранном языке. Но в тех, что я просмотрел
объяснение было построено так. Брался принцип, давалась его определение и приводился какой-то пример кода с
комментариями. Чтоб эта статья не получилась еще одной очередной статьей про SOLID я поменяю принцип подачи информации. Я
буду добавлять код не большими инкрементами и на каждом инкременте писать какие принципы SOLID в данном инкременте
применены. Это авторский текст (не перевод) с теми примерами которые я обычно использую для объяснения принципов SOLID.
Прошу отнестись к тексту снисходительно.

## Теория

Я не буду повторяться. В интернете много материала. Приведу только пару ссылок
Википедия [SOLID](https://ru.wikipedia.org/wiki/SOLID_(программирование)). Ну и
первоисточник [butunclebob.com](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).

## Принцип инверсии зависимостей

В моем идеальном мире SOLID начинается с принципа инверсии зависимостей. Википедия нам дает такое определение 
```
Классы должны зависеть от абстракций, а не от конкретных деталей.

A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_инверсии_зависимостей)

Это определение совершенно.

```
"Совершенство достигается не тогда, когда нечего добавить, а когда нечего убрать".
Антуан де Сент-Экзюпери.
```

Я осознанно начинаю с последнего принципа, потому что при написании кода я сталкиваюсь с ним с самым первым.
Если у вас нет зависимости на абстракциях, то SOLID не полноценный и понять его значительно сложнее.

```python
# Здесь и далее весь код убрать под спойлеры.
from abc import ABC, abstractmethod


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""
```

Начнем разбираться по порядку. ABC это класс помощник который всего только указывает метакласс `metaclass=ABCMeta`
вариант `class AbstractAuthUser(metaclass=abc.ABCMeta):` тоже рабочий, но Python предлагает нам синтаксический сахар мы
его и используем. Оставим первый вариант.

Декоратор `abstractmethod` гарантирует что у всех методов дочернего класса будут все методы которые декорированы этим
декоратором. Этим декоратором нужно оборачивать все методы которые будет использовать бизнес логика. Коллеги которые из
своего кода будут обращаться к классу аутентификации могут быть уверены, что у него всегда есть
методы `is_authenticated`, `get_email`, `get_department` потому, что они декарированы `abstractmethod` и поэтому 
обязательны для реализации в классах дочерних от абстрактного.

Отнаследуемся от абстрактного класса. Создадим класс, который будет проверять аутентификацию через Active Directory.
Если все сделано правильно, то код ниже в момент запуска выдаст ошибку.

```python
from abc import ABC, abstractmethod


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""


class AuthUserAD(AbstractAuthUser):
    pass


auth = AuthUserAD()

# Traceback (most recent call last):
#  File "/home/pavel/Projects/solid/solid.py", line 38, in <module>
#    auth = AuthUserAD()
#           ^^^^^^^^^^^^
# TypeError: Can't instantiate abstract class AuthUserAD with abstract methods get_department, get_email, is_authenticated
```

Это происходит потому, что в нашем классе нет обязательных методов. Но когда эти методы добавим все станет хорошо.

```python
from abc import ABC, abstractmethod


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""


class AuthUserAD(AbstractAuthUser):
    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()


auth = AuthUserAD()
```

В абстрактном классе стоит указывать методы, которые будут вызываться из вне. Это своего рода API класса (компонента).
Те же методы которые не должны использоваться из вне не нужно указывать в абстрактном классе. При
реализации `AuthUserAD` методы не являются частью API класса можно пометить одним подчеркиванием в начале
имени. [PEP8](https://peps.python.org/pep-0008/#descriptive-naming-styles)

Если вы в своем коде уже используете абстрактные классы, то скоре всего у вас в коде с SOLID все хорошо. Ниже при
описании остальных принципов мы часто будем возвращаться к этому принципу.



Теперь у нас есть абстрактный класс. От него зависит класс реализующий логику. Получается классы должны зависеть от 
абстракции.


## Принцип открытости/закрытости

Википедия описывает два подхода к пониманию этого принципа 

### Принцип открытости/закрытости Мейера

Однажды разработанная реализация класса в дальнейшем требует только исправления ошибок, а новые или изменённые функции
требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса через механизм
наследования. Производный подкласс может реализовывать или не реализовывать интерфейс исходного класса.

Определение Мейера поддерживает идею наследования реализации. Реализация может быть переопределена через наследование,
но спецификации интерфейса могут измениться. Существующая реализация должна быть закрыта для изменений, но новые
реализации не обязаны использовать существующий интерфейс*. 

### Полиморфный принцип открытости/закрытости

Это определение поддерживает идею наследования от абстрактных базовых классов. Спецификации интерфейсов могут быть
переиспользованы через наследование, но реализации переиспользовать необязательно. Существующий интерфейс должен быть
закрыт для модификаций, а новые реализации должны, по меньшей мере, реализовывать этот интерфейс*.

[Wiki](https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости)

*Что такое интерфейс подробно раздерем в `Принцип разделения интерфейса`. 

На собеседованиях соискатель иногда приводит примеры, которые подходят для `Принцип открытости/закрытости Мейера`. Когда 
для добавления нового функционала мы не меняем существующий класс, а наследуемся от него и в новый класс дбавляем нужный 
нам метод.

Но такой подход идет в разрез с `Принципом подстановки Лисков` (о нем ниже). У себя в коде мы используем `Полиморфный 
принцип открытости/закрытости`. В тексте и в примерах я описываю именно его. 

Давайте предположим что `AuthUserAD` это жуткое легаси которому лет 6. И из тех разработчиков которые его писали уже
никого нет. `AuthUserAD` регулярно DDOS-ит и роняет сервер аутентификации. Админ предлагает дешевое решение поднять
несколько инстансов [Keycloak](https://ru.wikipedia.org/wiki/Keycloak). Инстансы Keycloak будет по крону ходить в AD и
брать на себя нагрузку, которая лежала на AD.

Вносить изменения в класс `AuthUserAD` плохая идея. Трудно спрогнозировать риски, которые могут произойти от новых
изменений. К тому же после внесения изменений его захочется переименовать, а это равносильно удалению класса. Если мы не
исправим все места где он вызывается по старому имени, то гарантированно уроним код.

Сейчас самое время вспомнить про принцип `Принцип открытости/закрытости`. Хорошей идеей будет не трогать класс
`AuthUserAD`. Сделать его осуждаемым и написать новый класс для работы с новой схемой аутентификации. В новом классе
вместо ошибок из Keycloak мы будем райзить наши кастомные ошибки.

```python
from abc import ABC, abstractmethod
import logging

logger = logging.getLogger('root')


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""


class AuthUserAD(AbstractAuthUser):

    def __init__(self, *args, **kwargs):
        logger.error('Class AuthUserAD is deprecated. You should use AuthUserKeycloak.')
        super().__init__(*args, **kwargs)

    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()


class AuthUserKeycloak(AbstractAuthUser):
    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()
```

Если мы где-то не заменили класс `AuthUserAD` на `AuthUserKeycloak` у нас все рано все будет работать так как класс
`AuthUserAD` мы не удалили и он все еще существует и работает лучше, чем прежде, так как нагрузка на AD уменьшится. В
логах мы будем видеть ошибку при каждом создании инстанса `AuthUserAD` и постепенно безболезненно выпилим его из всех
возможных мест. Принцип открытости/закрытости работает на нас.

Принцип открытости/закрытости настолько сильно связан с принципом инверсии зависимостей, что можно сказать что второе 
это первое, но под немного другим ракурсом.

Теперь у нас есть абстрактный класс `AbstractAuthUser`. От него зависят оба класс реализации `AuthUserAD` и `AuthUserKeycloak`. 
И нам не важны детали реализации каждого класса из них. Классу `AuthUserKeycloak` все рано как реализован класс `AuthUserAD` и
реализован ли он вообще. Также у нас абстракция не зависит от деталей. Классу `AbstractAuthUser` все равно на детали 
реализации дочерних классов `AuthUserAD` на `AuthUserKeycloak`. Пусть там хоть класс с заглушками для тестов `AuthTest`.
Так же мы добавили новый функционал в классе AuthUserKeycloak не меняя закрытый для изменения класс AuthUserAD. 
Тем самым соблюли `принцип открытости/закрытости`.

```python
class AuthTest(AbstractAuthUser):
    """Класс аутентификации для тестов"""
    def is_authenticated(self) -> bool:
        """Метод возвращает значение необходимое для тестов"""
        return True

    def get_email(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return 'skyworker@jedi.com'

    def get_department(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return 'Департамент света'


class NoAuthTest(AbstractAuthUser):
    """Класс аутентификации для тестов"""
    def is_authenticated(self) -> bool:
        """Метод возвращает значение необходимое для тестов"""
        return False

    def get_email(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return ''

    def get_department(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return ''
```

## Принцип подстановки Лисков

```
функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_подстановки_Лисков)

Я считаю что этот принцип это самое сердце SOLID. Это то ради чего SOLID и задумывался. Этот принцип сильно связан, даже 
переплетен с уже мной описанными.

В наших классах кроме обязательных методов, описанных в абстрактном классе, могут быть различные свои методы. У таких
методов могут быть отличные сигнатуры. Могут отличиться названия методов. Ну и может отличиться реализация. Как же без
полиморфизма. Например, разные методы для http запроса на сервис аутентификации. Могут быть разные методы для проверки
токена, получения почты и названия отдела. Это не противоречит SOLID. Это в конце концов может быть класс с заглушками 
для тестирования без вообще каких либо дополнительных методов. Главное чтоб бизнес логика работала только с
методами из абстрактного класса. И сигнатуры методов с которыми буде работать бизнес логика были одинаковые.

Может показаться не очевидным, но в Python для принципа подстановки Лисков ограничиваться только методами описанными в
абстрактном классе может быть не достаточно. Если класс `AuthUserAD` и класс `AuthUserKeycloak` райзит разные ошибки, то
получается что классы не удовлетворяют `принципу подстановки Лисков`. В контексте SOLID использование кастомных исключений
это больше чем хорошая практика. Это расширение понимания принципа подстановки Лисков. Мы знаем какие ошибки могут 
прилететь поэтому очень крутой идеей будет написать свои кастомные ошибки. Не пробрасывать
ошибки из AD и из Keycloak, а обрабатывать их в классе и райзить свои.

```python
class AuthException(Exception):
    pass


class InvalidCredential(AuthException):
    pass


class AuthenticationServerIsNotAvailable(AuthException):
    pass
```

Так как новый класс `AuthUserKeycloak` реализует такие-же обязательные методы, как и `AuthUserAD`. И райзит те же самые
ошибки то в ручке (или миделваре) где использовался класс `AuthUserAD` или его инстансы мы можем безболезненно заменить
его на новый `AuthUserKeycloak`. При такой реализации принцип подстановки Лисков работает. Для меня это самое важное в 
SOLID. Мы написали наши классы так что любая наша реализация может быль заменена без внесения изменения в код. 

Здесь хочу сделать не большое замечание. Декоратор `abstractmethod` гарантирует что обязательные методы будут созданы, но
он позволяет создать их с различными сигнатурами. А для `Принципа подстановки Лисков` важно чтоб сигнатуры были
одинаковые или хотя бы совместимые. Без этого заменить базовый класс дочерним или один дочерний другим дочерним классом
без не получится.

Возможно кто-то скажет что принцип подстановки Лисков это про базовый тип и дочерний. И определение в википедии говорит
об этом. `"Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная 
об этом"`. Но нам ни чего не мешает сделать наследование так.

```python
class AuthUserAD(AbstractAuthUser):

    def __init__(self, *args, **kwargs):
        logger.error('Class AuthUserAD is deprecated. You should use AuthUserKeycloak.')
        super().__init__(*args, **kwargs)

    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()


class AuthUserKeycloak(AuthUserAD):
    def is_authenticated(self) -> bool:
        raise NotImplementedError()
```

Так как у нас `AuthUserKeycloak` реализует такие-же обязательные методы, как и `AuthUserAD` это ни как не повлияет на
возможность использования одного класса вместо другого. Если например реализация методов `get_email` и `get_department` в
`AuthUserKeycloak` такое же как в `AuthUserAD` то такое наследование возможно.

Но если у `AuthUserKeycloak` своя реализация всех методов API класса то такое наследование не нужно. Кроме этого мы
получим нежелательный побочный эффект. В экземпляре метода `AuthUserKeycloak` нам доступны все методы базового класса.

Я считаю что при любом, даже сложном, наследовании. Если мы можем один класс заменить другим то они соответствуют
принципу подстановки Лисков.

С наиболее сложными для понимания принципами закончили. Остались те которые обычно не вызывают трудностей.

## Принцип единственной ответственности

```
Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. 
Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности)

Здесь все просто. У класса `AuthUserKeycloak` может быть только одна причина для внесения в него изменений. И это 
какие-то изменения в аутентификации или в работу с Keycloak. Если вы вносите изменения в класс для добавления новых 
пермишенов или для 
изменения способа сохранения, то это дополнительные причины. А по принципу причина должна быть одна. Поэтому авторизацию 
и работу с пермишинами можно вынести в отдельный класс. Чтоб замена `AuthUserKeycloak` 
обратно на `AuthUserAD` не влияла на пермишены и на то какие действия для пользователя авторизированы (разрешены), а 
какие не авторизированы (запрешены). Также и хранение данных если класс `AuthUserKeycloak` сохраняет какие-то данные, 
то можно создать метод для этого действия, а он уже будет работать с экземпляром класса для хранения. Логика открытия 
файла или открытия соединения, логика сохранения файла в файл или базу, закрытия файла или соеденения должны быть 
вынесена из класса `AuthUserKeycloak` в соответствующей метод класса отвечающего за работу с хранилищем.

Для хранилища будет хорошей идеей создать абстрактный класс для хранения, а потом от него наследуем дочерние классы 
например для хранения в файле,
в базе данных через ORM, в Монго или другие варианты. А инстанс для нужного способа хранения использовать в `AuthUserKeycloak`. У меня
обычно есть один абстрактный и одни класс для ORM. Который я и использую для хранения например StoreFile или StoreDB

```python
from abc import ABC, abstractmethod


class AbstractStore(ABC):
    @abstractmethod
    def get(self, *args, **kwargs):
        pass

    @abstractmethod
    def get_multi(self, *args, **kwargs):
        pass

    @abstractmethod
    def create(self, *args, **kwargs):
        pass

    @abstractmethod
    def update(self, *args, **kwargs):
        pass

    @abstractmethod
    def delete(self, *args, **kwargs):
        pass


class StoreFile(AbstractStore):
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError

    def create(self, *args, **kwargs):
        raise NotImplementedError

    def update(self, *args, **kwargs):
        raise NotImplementedError

    def delete(self, *args, **kwargs):
        raise NotImplementedError


class StoreDB(AbstractStore):  # Для ORM
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError

    def create(self, *args, **kwargs):
        raise NotImplementedError

    def update(self, *args, **kwargs):
        raise NotImplementedError

    def delete(self, *args, **kwargs):
        raise NotImplementedError


class StoreMongo(AbstractStore):
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError

    def create(self, *args, **kwargs):
        raise NotImplementedError

    def update(self, *args, **kwargs):
        raise NotImplementedError

    def delete(self, *args, **kwargs):
        raise NotImplementedError
```

## Принцип разделения интерфейса

И последний незатронутый принцип. Для того чтоб его понять нужно определиться с понятиями. Что же такое интерфейс?
Проблема в том что в Python нет явного понятия интерфейса как в некоторых других языках программирования.

Если своими словами, то интерфейс это
абстракция которая позволяет определить методы без конкретной реализации. И если в классе есть все методы интерфейса то
в можно сказать что класс реализует интерфейс.

Получается что интерфейсам про которые говорится в `принципе разделения интерфейса` больше всего соответствуют 
абстрактные классы. После этого пояснения принцип становится очевидным. И что означает "много интерфейсов,
специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения" теперь понятно.

Приведу пример с абстрактным классом для коллектора. 

```python
from abc import ABC, abstractmethod


class AbstractCollector(ABC):

    def __init__(self) -> None:
        self.metrics = []
        self.prepared_metrics = []

    def collect(self) -> None:
        self.get_metrics_from_service()
        self.process_metrics()
        self.save_metrics()

    @abstractmethod
    def get_metrics_from_service(self) -> None:
        """Extract."""

    @abstractmethod
    def process_metrics(self) -> None:
        """Transform."""

    @abstractmethod
    def save_metrics(self) -> None:
        """Load."""


class AbstractStore(ABC):
    @abstractmethod
    def get(self, *args, **kwargs):
        pass

    @abstractmethod
    def get_multi(self, *args, **kwargs):
        pass

    @abstractmethod
    def create(self, *args, **kwargs):
        pass

    @abstractmethod
    def update(self, *args, **kwargs):
        pass

    @abstractmethod
    def delete(self, *args, **kwargs):
        pass


class AbstractReadOnlyStore(ABC):
    @abstractmethod
    def get(self, *args, **kwargs):
        pass

    @abstractmethod
    def get_multi(self, *args, **kwargs):
        pass


class GetStoreDB:
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError


class CreateStoreDB:
    def create(self, *args, **kwargs):
        raise NotImplementedError


class UpdateStoreDB:
    def update(self, *args, **kwargs):
        raise NotImplementedError


class DeleteStoreDB:
    def delete(self, *args, **kwargs):
        raise NotImplementedError


class StoreReadOnlyDB(AbstractReadOnlyStore, GetStoreDB):
    pass


class StoreDB(AbstractStore, GetStoreDB, CreateStoreDB, UpdateStoreDB, DeleteStoreDB):
    pass
```

Прежде чем объяснять что тут происходит, еще раз вспомним теорию.

```
Программные сущности не должны зависеть от методов, которые они не используют.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и
специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе.
В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_разделения_интерфейса)

В примере реализовано два абстрактных класса для работы с данными `AbstractStore`, `AbstractReadOnlyStore` и класс 
абстрактного коллектора `AbstractCollector`. 

Метод коллектора `get_metrics_from_service` ходит в инфраструктуру и имеет доступ к критичным данным. В разных коллекторах 
данные собираются из различных источников (api, базы данных, файлы и др.) Но это всегда выполняется только сбор данных 
(только безопасные методы). Методы, которые принято относить к опасным, не будут в нем использоваться. Поэтому при 
написании класса для сбора данных нужно использовать `AbstractReadOnlyStore`. Тогда потенциально опасные методы будут 
исключены на уровне интерфейса.

Метод коллектора `save_metrics` обычно выполняет только запись в базу данных. Получается что для написания класса 
сохранения в базу достаточно реализовать только `create` и `update`. И данная реализация позволяет нам легко собрать такой 
класс.

```python
class StoreReadOnlyDB(CreateStoreDB, UpdateStoreDB):
    pass
```

Хотя это и будет наиболее соответствующий принципу разделения интерфейса класс на практике мы так не делаем. А 
наследуемся от `AbstractStore` и в нем реализуются все методы CRUD. Можно сказать что интерфейс с полным CRUD будет 
толстым для функционала сохранения. 

Принцип разделения интерфейсов тесно связан с принципом единой ответственности. Если класс StoreReadOnlyDB занимается
только сбором статистики. И в соответствии с принципом единой ответственности мы не закладываем в него другой функционал.
Так же в соответствии с принципом разделения интерфейсов из абстрактного класса (интерфейса) убираем методы, которые не
будем использовать.

## Заключение

Примеры в статье приведены на python, но хочу заметить принципы не только про классы, а про программные сущности.
В моем понимании принципы SOLID с таким же успехам могут быть применены к микросервисам и архитектуре.

Я надеюсь что сейчас принципы SOLID стали для вас таким же очевидным как для `Роберта С. Мартина`. Поняли что все принципы
тесно связаны друг с другом. Надеюсь что статья и примеры дополнили информацию из других источников. Помогли собраться в
законченную картину. Понять насколько тесно принципы связанны между собой. Что вы теперь легко ответите на все вопросы 
по SOLID на собеседовании. И будете писать солидный код.

Все правила, в том числе и SOLID, можно нарушать. В небольших проектах строгое соблюдение всех принципов SOLID
избыточно. Но программисты, которые пишут небольшие проекты, растут. Растут и их проекты. Становятся большими, очень
большими и архитектурно сложными. В таких проектах соблюдение принципов SOLID крайне желательно или обязательно.

Если в тексте есть неточности или ошибки поправьте меня. Это тема с подводными камнями и тут есть где ошибиться.
