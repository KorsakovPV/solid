# Solid это не сложно. С примерами на Python

## Введение

Привет, Хабр! Меня зовут Павел Корсаков, я python-разработчик, в облачном
провайдере [beeline cloud](https://cloud.beeline.ru/?utm_source=owned_media&utm_medium=habr&utm_campaign=beeline_cloud&utm_term=bpod-kapotom-python-tonkosti-populyarnyh-konstrukciy-with-i-contextmanager).

Почти на всех на собеседованиях есть вопрос про SOLID: 
- что такое SOLID? 
- Зачем он нужен? 
- Как кандидат его применяет? 
- Как понимает принципы из него? 

Мы тоже спрашиваем про SOLID потому, что он часто бывает аргументом на ревью. 
Знания принципа помогает снять градус накала в комментфриях под мёрдж реквестом.

Но вернемся к кандидатам. Чаще всего он рассказывает что SOLID это акроним, называет все принципы, но объяснить и
привести примеры может только для половины. На остальных либо плавает, либо сливается.

Интернет по SOLID предлагает множество статей, - как на русском, так и на иностранном языке. Но в тех, что я просмотрел
объяснение было построено так: 
- брался принцип, 
- давалась его определение,
- приводился какой-то пример кода с комментариями. 

Чтоб эта статья не получилась еще одной очередной статьей про SOLID я поменяю принцип подачи информации. Я
буду добавлять код небольшими инкрементами и на каждом инкременте писать какие принципы SOLID в данном инкременте
применены. Это авторский текст (не перевод) с теми примерами которые я обычно использую для объяснения принципов SOLID.

## Теория

Я не буду повторяться. В интернете много материала. Приведу только пару ссылок
Википедия [SOLID](https://ru.wikipedia.org/wiki/SOLID_(программирование)). Ну и
первоисточник [butunclebob.com](http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod).

## Принцип инверсии зависимостей

В моем идеальном мире SOLID начинается с принципа инверсии зависимостей. Википедия нам дает такое определение 
```
Классы должны зависеть от абстракций, а не от конкретных деталей.

A. Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.
B. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_инверсии_зависимостей)

Это определение совершенно.

```
"Совершенство достигается не тогда, когда нечего добавить, а когда нечего убрать".
Антуан де Сент-Экзюпери.
```

Я осознанно начинаю с последнего принципа, потому что при написании кода я сталкиваюсь с ним с самым первым.
Если у вас нет зависимости на абстракциях, то SOLID не полноценный и понять его значительно сложнее.

```python
# Здесь и далее весь код убрать под спойлеры.
from abc import ABC, abstractmethod


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""
```

Начнем разбираться по порядку. ABC это класс-помощник, который указывает метакласс `metaclass=ABCMeta`
в качестве параметров класса. Вариант `class AbstractAuthUser(metaclass=abc.ABCMeta):` тоже рабочий, но Python предлагает нам синтаксический сахар мы
его и используем. Оставим первый вариант.

Декоратор `abstractmethod` гарантирует что у дочернего класса будут все методы которые декорированы этим
декоратором. Им нужно оборачивать все методы которые будет использовать бизнес-логика. Разработчики, которые 
будут обращаться к классу аутентификации могут быть уверены, что у него всегда есть
методы `is_authenticated`, `get_email`, `get_department` потому, что они декорированы `abstractmethod`, а значит 
обязательны для реализации в дочерних классах, унаследованных от абстрактного.

```python
from abc import ABC, abstractmethod


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""


class AuthUserAD(AbstractAuthUser):
    """Класс аутентификации через AD"""


auth = AuthUserAD()

# Traceback (most recent call last):
#  File "/home/pavel/Projects/solid/solid.py", line 38, in <module>
#    auth = AuthUserAD()
#           ^^^^^^^^^^^^
# TypeError: Can't instantiate abstract class AuthUserAD with abstract methods get_department, get_email, is_authenticated
```

Давайте их объявим.

```python
from abc import ABC, abstractmethod


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""


class AuthUserAD(AbstractAuthUser):
    """Класс аутентификации через AD"""
    
    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()


auth = AuthUserAD()
```

В абстрактном классе стоит указывать методы, которые будут вызываться извне. Это своего рода API класса (компонента).
В свою очередь, методы которые не должны использоваться извне не следует указывать в абстрактном классе. При
реализации `AuthUserAD` методы не являющиеся частью API класса можно пометить одним подчеркиванием в начале
имени. [PEP8](https://peps.python.org/pep-0008/#descriptive-naming-styles)

Теперь у нас есть абстрактный класс. От него зависит класс реализующий логику. Рекомендация классы должны зависеть от 
абстракций реализована.

Если вы в своем коде уже используете абстрактные классы, то скоре всего у вас в коде с SOLID все хорошо. Ниже при
описании остальных принципов мы часто будем возвращаться к этому принципу.

## Принцип открытости/закрытости

Википедия описывает два подхода к пониманию этого принципа 

### Принцип открытости/закрытости Мейера

Однажды разработанная реализация класса в дальнейшем требует только исправления ошибок, а новые или изменённые функции
требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса через механизм
наследования. Производный подкласс может реализовывать или не реализовывать интерфейс исходного класса.

Определение Мейера поддерживает идею наследования реализации. Реализация может быть переопределена через наследование,
но спецификации интерфейса могут измениться. Существующая реализация должна быть закрыта для изменений, но новые
реализации не обязаны использовать существующий интерфейс*. 

### Полиморфный принцип открытости/закрытости

Это определение поддерживает идею наследования от абстрактных базовых классов. Спецификации интерфейсов могут быть
переиспользованы через наследование, но реализации переиспользовать необязательно. Существующий интерфейс должен быть
закрыт для модификаций, а новые реализации должны, по меньшей мере, реализовывать этот интерфейс*.

[Wiki](https://ru.wikipedia.org/wiki/Принцип_открытости/закрытости)

*Что такое интерфейс подробно разберем в `Принцип разделения интерфейса`. 

На собеседованиях соискатель иногда приводит примеры, которые подходят для `Принципа открытости/закрытости Мейера`. 
Суть которого сводится к тому, что для добавления нового функционала мы не меняем существующий класс, а наследуемся от него и уже новом классе добавляем нужный 
нам метод.

Но такой подход идет в разрез с `Принципом подстановки Лисков` (о нем ниже). У себя в коде мы используем `Полиморфный 
принцип открытости/закрытости`. В тексте и в примерах я описываю именно его. 

Давайте предположим что `AuthUserAD` это жуткое легаси которому лет 6. И из тех разработчиков которые его писали уже
никого не осталось (в живых :) ). `AuthUserAD` регулярно DDOS-ит и роняет сервер аутентификации. Админ предлагает дешевое решение поднять
несколько инстансов [Keycloak](https://ru.wikipedia.org/wiki/Keycloak). Инстансы Keycloak будут ходить в AD по расписанию, получать список всех пользователей и
брать на себя нагрузку, которая лежала на AD.

Вносить изменения в класс `AuthUserAD` плохая идея. Трудно спрогнозировать риски, которые могут произойти от новых
изменений. К тому же после внесения изменений его захочется переименовать, а это равносильно удалению класса. Если мы не
исправим все места где он вызывается по старому имени, то гарантированно уроним код.

Сейчас самое время вспомнить про `принцип открытости/закрытости`. Хорошей идеей будет не трогать класс
`AuthUserAD`. Сделать его осуждаемым и написать новый класс для работы с новой схемой аутентификации. В новом классе
вместо ошибок из Keycloak мы будем райзить наши кастомные ошибки.

```python
from abc import ABC, abstractmethod
import logging

logger = logging.getLogger('root')


class AbstractAuthUser(ABC):
    """Абстрактный класс, реализующий обязательные методы."""

    @abstractmethod
    def is_authenticated(self) -> bool:
        """
        Метод проверяет аутентификацию пользователя.
        Возвращает True если аутентифицирован и False если не аутентифицирован
        """

    @abstractmethod
    def get_email(self) -> str:
        """Метод возвращает email пользователя"""

    @abstractmethod
    def get_department(self) -> str:
        """Метод возвращает отдел в котором работает пользователь"""


class AuthUserAD(AbstractAuthUser):
    """Класс аутентификации через AD"""

    def __init__(self, *args, **kwargs):
        logger.error('Class AuthUserAD is deprecated. You should use AuthUserKeycloak.')
        super().__init__(*args, **kwargs)

    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()


class AuthUserKeycloak(AbstractAuthUser):
    """Класс аутентификации через Keycloak"""
    
    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()
```

Если мы где-то не заменили класс `AuthUserAD` на `AuthUserKeycloak` у нас все равно все будет работать так как класс
`AuthUserAD` мы не удалили. Он все еще существует в коде и работает лучше, чем прежде, так как нагрузка на AD уменьшится. В
логах мы будем видеть ошибку при каждом создании инстанса `AuthUserAD` и постепенно безболезненно выпилим его из всех
возможных мест. Принцип открытости/закрытости работает на нас.

Принцип открытости/закрытости настолько сильно связан с принципом инверсии зависимостей, что можно сказать что второе 
это первое, но под немного другим ракурсом.

Теперь у нас есть абстрактный класс `AbstractAuthUser`. От него зависят оба класс реализации `AuthUserAD` и `AuthUserKeycloak`. 
Причем нам не важны детали реализации каждого конкретного класса. Классу `AuthUserKeycloak` все равно как реализован класс `AuthUserAD` и
реализован ли он вообще. Также у нас абстракция не зависит от деталей: классу `AbstractAuthUser` не важны детали 
реализации дочерних классов `AuthUserAD` на `AuthUserKeycloak` например, класс с заглушками для тестов `AuthTest`.
Более того, мы добавили новый функционал в классе AuthUserKeycloak не меняя закрытый для изменения класс AuthUserAD. 
Тем самым соблюли `принцип открытости/закрытости`.

```python
class AuthTest(AbstractAuthUser):
    """Класс аутентификации для тестов"""
    
    def is_authenticated(self) -> bool:
        """Метод возвращает значение необходимое для тестов"""
        return True

    def get_email(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return 'skyworker@jedi.com'

    def get_department(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return 'Департамент света'


class NoAuthTest(AbstractAuthUser):
    """Класс аутентификации для тестов"""
    
    def is_authenticated(self) -> bool:
        """Метод возвращает значение необходимое для тестов"""
        return False

    def get_email(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return ''

    def get_department(self) -> str:
        """Метод возвращает значение необходимое для тестов"""
        return ''
```

## Принцип подстановки Лисков

```
функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_подстановки_Лисков)

Я считаю что этот принцип это самое сердце SOLID. Это то ради чего SOLID и задумывался. Этот принцип сильно связан, даже 
переплетен с уже мной описанными.

В наших классах помимо обязательных методов, описанных в абстрактном классе, могут быть свои методы. В них
могут быть отличные сигнатуры, могут отличаться названия методов, ну и может отличаться реализация (как же без
полиморфизма). Например, разные методы для http запроса на сервис аутентификации, могут быть разные методы для проверки
токена, получения почты и названия отдела. Это не противоречит SOLID. Главное чтобы бизнес-логика работала только с
методами из абстрактного класса. И сигнатуры методов с которыми будет работать бизнес-логика были одинаковыми.

Может показаться неочевидным, но в Python для принципа подстановки Лисков ограничиваться только методами описанными в
абстрактном классе может быть недостаточно. Если класс `AuthUserAD` и класс `AuthUserKeycloak` рейзит разные ошибки, то
получается что классы не удовлетворяют `принципу подстановки Лисков`. В контексте SOLID использование кастомных исключений
это больше чем просто хорошая практика - это расширение понимания принципа подстановки Лисков. Мы знаем какие ошибки могут 
прилететь поэтому будет очень крутой идеей написать свои кастомные ошибки. Не пробрасывать
ошибки из AD и из Keycloak, а обрабатывать их в самом классе и рейзить свои исключения.

```python
class AuthException(Exception):
    pass


class InvalidCredential(AuthException):
    pass


class AuthenticationServerIsNotAvailable(AuthException):
    pass
```

Так как новый класс `AuthUserKeycloak` реализует такие-же обязательные методы, как и `AuthUserAD`. И рейзит те же самые
ошибки, то в эндпоинте (или middleware) где использовался класс `AuthUserAD` или его инстансы мы можем безболезненно заменить
его на новый `AuthUserKeycloak`. При такой реализации принцип подстановки Лисков работает. Для меня это самое важное в 
SOLID. Мы написали наши классы так что любая наша реализация может быль заменена без внесения изменения в код. 

Здесь хочу сделать небольшое замечание. Декоратор `@abstractmethod` гарантирует что обязательные методы будут созданы, но
он позволяет создать их с различными сигнатурами. А для `Принципа подстановки Лисков` важно чтоб сигнатуры были
одинаковые или хотя бы совместимые. Без этого заменить базовый класс дочерним или один дочерний другим дочерним классом
не получится.

Возможно кто-то скажет что принцип подстановки Лисков это про базовый тип и дочерний. И определение в википедии говорит
об этом. `"Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная 
об этом"`. Но нам ни чего не мешает сделать наследование так.

```python
class AuthUserAD(AbstractAuthUser):
    """Класс аутентификации через AD"""

    def __init__(self, *args, **kwargs):
        logger.error('Class AuthUserAD is deprecated. You should use AuthUserKeycloak.')
        super().__init__(*args, **kwargs)

    def is_authenticated(self) -> bool:
        raise NotImplementedError()

    def get_email(self) -> str:
        raise NotImplementedError()

    def get_department(self) -> str:
        raise NotImplementedError()


class AuthUserKeycloak(AuthUserAD):
    """Класс аутентификации через Keycloak"""
    
    def is_authenticated(self) -> bool:
        raise NotImplementedError()
```

Так как у нас `AuthUserKeycloak` реализует такие-же обязательные методы, как и `AuthUserAD` это никак не повлияет на
возможность использования одного класса вместо другого. Если, например, реализация методов `get_email` и `get_department` в
`AuthUserKeycloak` такое же как в `AuthUserAD` то такое наследование возможно.

Но если у `AuthUserKeycloak` своя реализация всех методов API класса то такое наследование не нужно. Кроме этого мы
получим нежелательный побочный эффект - в экземпляре метода `AuthUserKeycloak` нам доступны все методы базового класса.

Я считаю что при любом (даже сложном) наследовании. Если мы можем один класс заменить другим - они соответствуют
принципу подстановки Лисков.

С наиболее сложными для понимания принципами закончили. Остались те которые обычно не вызывают трудностей.

## Принцип единственной ответственности

```
Каждый объект должен иметь одну ответственность и эта ответственность должна быть полностью инкапсулирована в класс. 
Все его поведения должны быть направлены исключительно на обеспечение этой ответственности.
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_единственной_ответственности)

Здесь все более прозрачно. У класса `AuthUserKeycloak` может быть только одна причина для внесения в него изменений. И это 
какие-то изменения в аутентификации или в работу с Keycloak. Если вы вносите изменения в класс для добавления новых 
пермишенов или для 
изменения способа сохранения, то это дополнительные причины, а по рассматриваемому нами принципу причина должна быть одна. Поэтому авторизацию 
и работу с пермишинами необходимо вынести в отдельный класс, чтобы замена `AuthUserKeycloak` 
обратно на `AuthUserAD` не влияла на пермишены и на то какие действия для пользователя авторизованы (разрешены), а 
какие не авторизованы (запрещены). 

Аналогичным образом монжо рассмотреть и хранение данных: если класс `AuthUserKeycloak` сохраняет какие-то данные, 
то можно создать метод для этого действия, а он уже будет работать с экземпляром класса для хранения. Логика открытия 
файла или открытия соединения, логика сохранения в файл или базу, закрытия файла или соединения должны быть 
вынесены из класса `AuthUserKeycloak` в соответствующий метод класса отвечающего за работу с хранилищем.

Для хранилища будет хорошей идеей создать абстрактный класс для хранения и уже от него наследовать дочерние классы. 
Например, для хранения в файле,
в SQL базах данных через ORM, в NoSQL базах или другие варианты, а инстанс для нужного способа хранения использовать в `AuthUserKeycloak`. У меня
обычно есть один абстрактный и один класс для ORM. Который я и использую для хранения например StoreFile или StoreDB

```python
from abc import ABC, abstractmethod


class AbstractStore(ABC):
    """Абстрактный класс для хранения"""
    
    @abstractmethod
    def get(self, *args, **kwargs):
        pass

    @abstractmethod
    def get_multi(self, *args, **kwargs):
        pass

    @abstractmethod
    def create(self, *args, **kwargs):
        pass

    @abstractmethod
    def update(self, *args, **kwargs):
        pass

    @abstractmethod
    def delete(self, *args, **kwargs):
        pass


class StoreFile(AbstractStore):
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError

    def create(self, *args, **kwargs):
        raise NotImplementedError

    def update(self, *args, **kwargs):
        raise NotImplementedError

    def delete(self, *args, **kwargs):
        raise NotImplementedError


class StoreDB(AbstractStore):  # Для ORM
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError

    def create(self, *args, **kwargs):
        raise NotImplementedError

    def update(self, *args, **kwargs):
        raise NotImplementedError

    def delete(self, *args, **kwargs):
        raise NotImplementedError


class StoreMongo(AbstractStore):
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError

    def create(self, *args, **kwargs):
        raise NotImplementedError

    def update(self, *args, **kwargs):
        raise NotImplementedError

    def delete(self, *args, **kwargs):
        raise NotImplementedError
```

## Принцип разделения интерфейса

И последний незатронутый принцип. Для того чтоб его понять нужно определиться с понятиями. Что же такое интерфейс?
Проблема в том что в Python нет явного понятия интерфейса как в некоторых других языках программирования.

Если своими словами, то интерфейс это
абстракция которая позволяет определить методы без конкретной реализации. И если в классе есть все методы интерфейса то
в можно сказать что класс реализует интерфейс.

Получается что интерфейсам про которые говорится в `принципе разделения интерфейса` больше всего соответствуют 
абстрактные классы. После этого пояснения принцип становится очевидным. И что означает "много интерфейсов,
специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения" теперь понятно.

Приведу пример с абстрактным классом для коллектора. 

```python
from abc import ABC, abstractmethod


class AbstractCollector(ABC):

    def __init__(self) -> None:
        self.metrics = []
        self.prepared_metrics = []

    def collect(self) -> None:
        self.get_metrics_from_service()
        self.process_metrics()
        self.save_metrics()

    @abstractmethod
    def get_metrics_from_service(self) -> None:
        """Extract."""

    @abstractmethod
    def process_metrics(self) -> None:
        """Transform."""

    @abstractmethod
    def save_metrics(self) -> None:
        """Load."""


class AbstractStore(ABC):
    @abstractmethod
    def get(self, *args, **kwargs):
        pass

    @abstractmethod
    def get_multi(self, *args, **kwargs):
        pass

    @abstractmethod
    def create(self, *args, **kwargs):
        pass

    @abstractmethod
    def update(self, *args, **kwargs):
        pass

    @abstractmethod
    def delete(self, *args, **kwargs):
        pass


class AbstractReadOnlyStore(ABC):
    @abstractmethod
    def get(self, *args, **kwargs):
        pass

    @abstractmethod
    def get_multi(self, *args, **kwargs):
        pass


class GetStoreDB:
    def get(self, *args, **kwargs):
        raise NotImplementedError

    def get_multi(self, *args, **kwargs):
        raise NotImplementedError


class CreateStoreDB:
    def create(self, *args, **kwargs):
        raise NotImplementedError


class UpdateStoreDB:
    def update(self, *args, **kwargs):
        raise NotImplementedError


class DeleteStoreDB:
    def delete(self, *args, **kwargs):
        raise NotImplementedError


class StoreReadOnlyDB(AbstractReadOnlyStore, GetStoreDB):
    pass


class StoreDB(AbstractStore, GetStoreDB, CreateStoreDB, UpdateStoreDB, DeleteStoreDB):
    pass
```

Прежде чем объяснять что тут происходит, еще раз вспомним теорию.

```
Программные сущности не должны зависеть от методов, которые они не используют.

Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и
специфические, чтобы программные сущности маленьких интерфейсов знали только о методах, которые необходимы им в работе.
В итоге, при изменении метода интерфейса не должны меняться программные сущности, которые этот метод не используют.
```
[Wiki](https://ru.wikipedia.org/wiki/Принцип_разделения_интерфейса)

В примере реализовано два абстрактных класса для работы с данными `AbstractStore`, `AbstractReadOnlyStore` и класс 
абстрактного коллектора `AbstractCollector`. 

Метод коллектора `get_metrics_from_service` ходит в инфраструктуру и имеет доступ к критичным данным. В разных коллекторах 
данные собираются из различных источников (api, базы данных, файлы и др.) Но это всегда выполняется только сбор данных 
(только безопасные методы). Методы, которые принято относить к опасным, не будут в нем использоваться. Поэтому при 
написании класса для сбора данных нужно использовать `AbstractReadOnlyStore`. Тогда потенциально опасные методы будут 
исключены на уровне интерфейса.

Метод коллектора `save_metrics` обычно выполняет только запись в базу данных. Получается что для написания класса 
сохранения в базу достаточно реализовать только `create` и `update`. И данная реализация позволяет нам легко собрать такой 
класс.

```python
class StoreReadOnlyDB(CreateStoreDB, UpdateStoreDB):
    pass
```

Хотя это и будет наиболее соответствующий принципу разделения интерфейса класс на практике мы так не делаем. А 
наследуемся от `AbstractStore` и в нем реализуются все методы CRUD. Можно сказать что интерфейс с полным CRUD будет 
толстым для функционала сохранения. 

Принцип разделения интерфейсов тесно связан с принципом единой ответственности. Если класс StoreReadOnlyDB занимается
только сбором статистики. И в соответствии с принципом единой ответственности мы не закладываем в него другой функционал.
Так же в соответствии с принципом разделения интерфейсов из абстрактного класса (интерфейса) убираем методы, которые не
будем использовать.

## Заключение

Примеры в статье приведены на python, но хочу заметить принципы не столько про классы, сколько про программные сущности.
В моем понимании принципы SOLID с таким же успехом могут быть применены, например, в архитектуре ПО, при описании схемы 
взаимодействия микросервисов.

Я надеюсь что после прочтения статьи принципы SOLID стали для вас такими же очевидными как для `Роберта С. Мартина`. Главная мысль, которую я хотел донести, это то, что все принципы
тесно связаны друг с другом. Надеюсь что этот текст дополнил информацию из других источников и помог собрать её в
законченную картину, понять насколько тесно принципы связаны между собой. Я верю, что вы теперь легко ответите на все вопросы 
по SOLID на собеседовании. И будете писать солидный код.

Все правила, в том числе и SOLID, можно нарушать. В небольших проектах строгое соблюдение всех принципов SOLID
избыточно. Но программисты, которые пишут небольшие проекты, растут. Растут и их проекты. Становятся большими, очень
большими и архитектурно сложными. В таких проектах соблюдение принципов SOLID крайне желательно или обязательно.
